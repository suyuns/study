### 18.继承

***

 	ECMAScript只支持实现继承（主要依靠原型链实现）





#### 原型链

***

 	让原型对象等于另一个类型的实例，另一个类型原型又是另一个类型实例，此关系即为原型链。

-  **搜索一个属性步骤：** 实例-->搜索原型链（直到搜索到原型链末端才会结束）

- **默认原型** ：

  -  所有引用类默认都继承了Object
  - 所有函数的默认原型都是Object（默认原型包含一个内部指针指向Object.prototype）

- **确定原型和实例的关系方法** 

  - **instanceof操作符**：测试实例与原型链中出现过的构造函数，会返回true
  - **isPrototypeOf()方法** ：只要原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，会返回true

- ##### 定义方法

   	给原型添加方法的代码一定要放在替换原型的语句之后（在通过原型链实现继承时，不能使用对象字面量创建方法，因为该方法会重写原型链）

- ##### 原型链的问题

  - **最主要问题**：包含引用类型的原型的问题（原先实例的属性会变成现在原型的属性）
  - 在创建子类型的实例时，不能向超类型的构造函数中传递参数





#### 借用构造函数（伪造对象或经典继承，少用）

***

- **思路**：在子类型构造函数的内部调用超类型构造函数（借用**apply()**和**call()**方法）
- **优势**：相比于原型链，借用构造函数可以在子类型的构造函数之中向超类型传递参数
- **问题：** 方法都在构造函数之中定义，函数复用无效





#### 组合继承（伪经典继承，最常用模式）

***

- **思路：** 将原型链和借用构造函数方法组合使用（原型链实现对原型属性和方法的继承，借用构造函数实现对实例属性的继承）





#### 原型式模式

***

- **思路：**借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型

- 特殊函数：

  ````javascript
  function object(o){
      function F(){}
      F.prototype=o;
      return new F();
  }
  ````

- **Object.create()**（es5规范了原型式继承）

  - 两个参数
  - 一为用作新对象原型的对象
  - 二为一个新对象定义额外属性的对象（可选）





#### 寄生式继续

***

- **思路：** 创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再向是真的是它做了所有工作一样返回对象。（类型工厂模式）

- **代码示范：**

  ```javascript
  function createAnother(original){
      var clone=Object(original);//通过调用函数创建一个新对象
      clone.sayHi=function(){//以某种方式来增强这个对象
          alert("hi");
      };
      return clone;//返回这个对象
  }
  ```

  







#### 寄生组合式继承

***

- **思路：** 通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。（本质上使用寄生模式来继承超类型的原型，然后将结果指定给子类型。

- **示例：**

  ```javascript
  function inheritPrototype(subType,superType){
      var prototype=object(superType.prototype);//创建对象
      prototype,constructor=subType;//增强
      subType.prototype=prototype;//指定
  }
  ```

  